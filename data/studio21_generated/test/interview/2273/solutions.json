["import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n\ninf = 1 << 20\nA, B, C = [], [], []\nX = [0] * N\nfor a in E[0]:\n    X[a] = 1\nA = [i for i in range(N) if X[i]==0]\nb = min([i for i in range(N) if X[i] == 1] + [inf])\nif b < inf:\n    for a in E[b]:\n        if X[a] == 1: X[a] = 2\n    B = [i for i in range(N) if X[i]==1]\nc = min([i for i in range(N) if X[i] == 2] + [inf])\nif c < inf:\n    for a in E[c]:\n        if X[a] == 2: X[a] = 3\n    C = [i for i in range(N) if X[i]==2]\n\nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\n    f = 0\n    for i in range(N):\n        for j in E[i]:\n            if X[i] == X[j]:\n                f = 1\n                break\n        if f: break\n    if f:\n        print(-1)\n    else:\n        print(*[x+1 for x in X])\nelse:\n    print(-1)\n", "n,m = list(map(int, input().split()))\n\nad = [[] for _ in range(n)]\n\nes = []\nfor _ in range(m):\n    v,u = list(map(int, input().split()))\n    v-=1\n    u-=1\n    es.append((min(v,u),max(v,u)))\nes = sorted(es, key=lambda x: (x[0], x[1]))\n\nfor e in es:\n    v, u = e\n    ad[v].append(str(u))\n    ad[u].append(str(v))\n\n\nad = [''.join(a) for a in ad]\nd = {}\nfor t in ad:\n    if t not in d:\n        d[t] = str(len(d) + 1)\n    if len(d) > 3:\n        print(-1)\n        return\nif len(d) != 3:\n    print(-1)\n    return\n\nans = []\nfor t in ad:\n    ans.append(d[t])\nprint(' '.join(ans))\n", "from collections import defaultdict, deque\n\n\ndef threeSets(vs, es, d):\n    sets = [3] * vs\n    \n    s1 = 0\n    dist = [float('inf')] * vs\n    sets[s1] = 1\n    dist[s1] = 0\n    queue = deque([s1])\n    while queue:\n        v1 = queue.pop()\n        for v2 in d[v1]:\n            if dist[v2] > dist[v1] + 1:\n                dist[v2] = dist[v1] + 1\n                queue.appendleft(v2)\n    \n    for i in range(vs):\n        if dist[i] > 2:\n            return [-1]\n        elif dist[i] == 2:\n            sets[i] = 1\n        \n    try:\n        s2 = sets.index(3)\n    except:\n        return [-1]\n    \n    dist = [float('inf')] * vs\n    sets[s2] = 2\n    dist[s2] = 0\n    queue = deque([s2])\n    while queue:\n        v1 = queue.pop()\n        for v2 in d[v1]:\n            if dist[v2] > dist[v1] + 1:\n                dist[v2] = dist[v1] + 1\n                queue.appendleft(v2)\n    \n    for i in range(vs):\n        if dist[i] > 2:\n            return [-1]\n        elif dist[i] == 2:\n            if sets[i] == 1:\n                return [-1]\n            else:\n                sets[i] = 2\n                \n    VS = [set() for i in range(3)]\n    for i in range(vs):\n        g = sets[i] - 1\n        VS[g].add(i)\n    for V in VS:\n        if not len(V):\n            return [-1]\n        \n    for v1 in VS[0]:\n        for v2 in VS[1]:\n            if v2 not in d[v1]:\n                return [-1]\n        \n        for v2 in VS[2]:\n            if v2 not in d[v1]:\n                return [-1]\n    \n    for v1 in VS[1]:\n        for v2 in VS[2]:\n            if v2 not in d[v1]:\n                return [-1]\n            \n    valid_es = len(VS[0]) * len(VS[1]) + len(VS[0]) * len(VS[2]) + len(VS[1]) * len(VS[2])\n    return sets if es == valid_es else [-1]       \n        \n    \nd = defaultdict(set)\n\nvs, es = list(map(int, input().split()))\nfor _ in range(es):\n    v1, v2 = list(map(int, input().split()))\n    v1 -= 1\n    v2 -= 1\n    d[v1].add(v2)\n    d[v2].add(v1)\n        \nprint(*threeSets(vs, es, d))\n", "# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for _ in range(N)]\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.size[px] < self.size[py]:\n            self.parent[px] = py\n            self.size[py] += self.size[px]\n        else:\n            self.parent[py] = px\n            self.size[px] += self.size[py]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def connectedNum(self, x):\n        return self.size[self.find(x)]\n\n    def component_NUM(self):\n        par = set()\n        for i in self.parent:\n            par.add(self.find(i))\n        return len(par)\n\n\nN, M = list(map(int, input().split()))\nadj = [set() for _ in range(N)]\nUn = UnionFind(N)\nfor _ in range(M):\n    a, b = [int(x)-1 for x in input().split()]\n    adj[a].add(b)\n    adj[b].add(a)\n\nadded = set()\nrepresentative = set()\nfor i in range(N):\n    if i in added:\n        continue\n    added.add(i)\n    representative.add(i)\n    for j in range(i+1, N):\n        if j in added:\n            continue\n        if adj[i] == adj[j]:\n            added.add(j)\n            Un.union(i, j)\n    if len(representative) > 3:\n        print(-1)\n        return\nif Un.component_NUM() == 3:\n    group = {}\n    ans = []\n    for p in range(N):\n        par = Un.find(p)\n        if par not in list(group.keys()):\n            group[par] = len(group)+1\n        ans.append(group[par])\n    print(\" \".join(map(str, ans)))\nelse:\n    print(-1)\n", "def main():\n    from array import array\n    from sys import stdin, stdout\n    n, m = list(map(int, stdin.readline().split()))\n    inp = {tuple(map(int, stdin.readline().split())) for _ in range(m)}\n    ans = array('b', (0,)) * (n + 1)\n    ans[1] = 1\n    c1 = 1\n    c2 = c3 = 0\n    i = 1\n    for j in range(2, n + 1):\n        if (1, j) not in inp:\n            ans[j] = 1\n            c1 += 1\n        else:\n            if i == 1:\n                i = j\n            if (i, j) in inp:\n                ans[j] = 2\n                c2 += 1\n            else:\n                ans[j] = 3\n                c3 += 1\n    if m != c1 * (c2 + c3) + c2 * c3 or not c2:\n        stdout.write('-1')\n    else:\n        for i, j in inp:\n            if ans[i] == ans[j]:\n                stdout.write('-1')\n                break\n        else:\n            stdout.write(' '.join((str(ansi) for ansi in ans if ansi)))\n\n\nmain()\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval, stdin, setrecursionlimit\nsetcheckinterval(1000)\nsetrecursionlimit(10**7)\n \n# print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n \n \ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\ndef BFS(s, adj):\n    parent = {s: None}\n    color = [-1]*(len(adj))\n    color[s]+=1\n    u = [s]\n    while u:  # runs till u is []\n        nextu = []\n        for i in u:\n            for v in adj[i]:\n                if v not in parent:\n                    color[v]=(color[i]+1)%3\n                    parent[v] = i\n                    nextu.append(v)\n                else:\n                    if color[v]==color[i]:\n                        color[v]=(color[v]+1)%3\n        u = nextu.copy()\n    for i in range(len(adj)):\n        color[i]+=1\n    return color\n\n\n\nn,m=lin()\nadj=[[] for i in range(n)]\nfor _ in range(m):\n    i,j=lin()\n    adj[i-1].append(j-1)\n    adj[j-1].append(i-1)\n\nsol=BFS(0, adj)\nc1=[0,0,0] #count of 1,2,3\nfor i in sol:\n    if i==0:\n        print(-1)\n        return\n    c1[i-1]+=1\nch=[[0 for i in range(3)] for j in range(3)] #12,13,23\n\nfor v in range(n):\n    for u in adj[v]:\n        ch[sol[v]-1][sol[u]-1]+=1\n#        ch[sol[u]-1][sol[v]-1]+=1\n        if sol[v]==sol[u]:\n            print(-1)\n            return\na12=ch[0][1]+ch[1][0]\na13=ch[0][2]+ch[2][0]\na23=ch[1][2]+ch[2][1]\n#print(a12,a13,a23,c1,sol)\nif a12==2*c1[0]*c1[1] and a13==2*c1[0]*c1[2] and a23==2*c1[1]*c1[2]:\n    print(*sol)\nelse:\n    print(-1)", "n, m = map(int, input().split())\nG = [[] for _ in range(n)]\nfor i in range(m):\n\ta, b = map(int, input().split())\n\ta -= 1\n\tb -= 1\n\tG[a].append(b)\n\tG[b].append(a)\n\nif len(G[0]) < 2:\n\tprint(-1)\n\treturn\n\nres = [1]*n\nfor a in G[0]:\n\tres[a] = 2\na2 = G[0][0]\nfor b in G[a2]:\n\tif res[b] == 2: res[b] = 3\nsizes = [n-len(G[0]), n-len(G[a2]), len(G[0])+len(G[a2])-n]\nif 0 in sizes:\n\tprint(-1)\n\treturn\n\nfor i in range(n):\n\tg = res[i]\n\ts = sizes[g-1]\n\tif len(G[i]) != n-s:\n\t\tprint(-1)\n\t\treturn\n\tfor j in G[i]:\n\t\tif res[j] == g:\n\t\t\tprint(-1)\n\t\t\treturn\n\nprint(*res)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nn, m = [int(item) for item in input().split()]\nab = []\nedges = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = [int(item) for item in input().split()]\n    a -= 1; b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n    ab.append((a, b))\n\n    \ngroupA = [1] * n\nfor a, b in ab:\n    if a == 0:\n        groupA[b] = 0\n    elif b == 0:\n        groupA[a] = 0\npar = None\nfor i, item in enumerate(groupA):\n    if item == 0:\n        par = i\n        break\nif par == None:\n    print(-1)\n    return\n\ngroupB = [1] * n\nfor a, b in ab:\n    if a == par:\n        groupB[b] = 0\n    elif b == par:\n        groupB[a] = 0\n\npar = None\nfor i, (p, q) in enumerate(zip(groupA, groupB)):\n    if p == 0 and q == 0:\n        par = i\n        break\nif par == None:\n    print(-1)\n    return\n\ngroupC = [1] * n\nfor a, b in ab:\n    if a == par:\n        groupC[b] = 0\n    elif b == par:\n        groupC[a] = 0\n\n# Check edge num\nsumA = sum(groupA)\nsumB = sum(groupB)\nsumC = sum(groupC)\ne_abc = [0, n - sumA, n - sumB, n - sumC]\nedge_num = sumA * sumB + sumB * sumC + sumC * sumA \nif edge_num != m:\n    print(-1)\n    return\n\n# Answer\nsetA = set()\nsetB = set()\nsetC = set()\ngroup = [groupA, groupB, groupC]\nret = []\nfor i, (ga, gb, gc) in enumerate(zip(groupA, groupB, groupC)):\n    total = ga + gb + gc\n    if total != 1:\n        print(-1)\n        return\n    if ga:\n        ret.append(1)\n        setA.add(i)\n    elif gb:\n        ret.append(2)\n        setB.add(i)\n    else:\n        ret.append(3)\n        setC.add(i)\ns_ABC = [set(), setA, setB, setC]\nfor i, item in enumerate(ret):\n    if e_abc[item] != len(edges[i]):\n        print(-1)\n        return\n    for node in edges[i]:\n        if node in s_ABC[item]:\n            print(-1)\n            return\nprint(\" \".join([str(item) for item in ret]))", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nE=[set() for i in range(n+1)]\nECOUNT=[0]*(n+1)\n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    E[x].add(y)\n    E[y].add(x)\n    ECOUNT[x]+=1\n    ECOUNT[y]+=1\n\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nSCORE=0\nfor i in range(1,n+1):\n    if find(i)==i:\n        SCORE+=1\n        if SCORE>=6:\n            print(-1)\n            return\n            \n        for j in range(i+1,n+1):\n            if j in E[i]:\n                continue\n            else:\n                Union(i,j)\n\nFD=[find(i) for i in range(n+1)]\nif len(set(FD[1:]))!=3:\n    print(-1)\n    return\n\nfor i in range(n+1):\n    for j in E[i]:\n        if FD[i]==FD[j]:\n            print(-1)\n            return\n\n\ncompression_dict={a: ind for ind, a in enumerate(sorted(set(FD)))}\nANS=[compression_dict[a] for a in FD]\n\nVFD=[0,0,0]\nEFD=[0,0,0]\nfor i in range(1,n+1):\n    VFD[ANS[i]-1]+=1\n    EFD[ANS[i]-1]+=ECOUNT[i]\n\nfor i in range(3):\n    VS=0\n    for j in range(3):\n        if i==j:\n            continue\n        VS+=VFD[i]*VFD[j]\n\n    if EFD[i]==VS:\n        continue\n    else:\n        print(-1)\n        return\n\n\nprint(*ANS[1:])\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nE=[set() for i in range(n+1)]\nECOUNT=[0]*(n+1)\n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    E[x].add(y)\n    E[y].add(x)\n    ECOUNT[x]+=1\n    ECOUNT[y]+=1\n\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nSCORE=0\nfor i in range(1,n+1):\n    if find(i)==i:\n        SCORE+=1\n        if SCORE>=4:\n            print(-1)\n            return\n            \n        for j in range(i+1,n+1):\n            if j in E[i]:\n                continue\n            else:\n                Union(i,j)\n\nFD=[find(i) for i in range(n+1)]\nif len(set(FD[1:]))!=3:\n    print(-1)\n    return\n\nfor i in range(n+1):\n    for j in E[i]:\n        if FD[i]==FD[j]:\n            print(-1)\n            return\n\n\ncompression_dict={a: ind for ind, a in enumerate(sorted(set(FD)))}\nANS=[compression_dict[a] for a in FD]\n\nVFD=[0,0,0]\nEFD=[0,0,0]\nfor i in range(1,n+1):\n    VFD[ANS[i]-1]+=1\n    EFD[ANS[i]-1]+=ECOUNT[i]\n\nfor i in range(3):\n    VS=0\n    for j in range(3):\n        if i==j:\n            continue\n        VS+=VFD[i]*VFD[j]\n\n    if EFD[i]==VS:\n        continue\n    else:\n        print(-1)\n        return\n\n\nprint(*ANS[1:])\n\n\n", "from sys import stdin\ninput = stdin.readline\nv, e = map(int,input().split())\nd = {}\nfor i in range(1, v+1):\n\td[i] = []\nfor ed in range(e):\n\ta,b = map(int,input().split())\n\td[a].append(b)\n\td[b].append(a)\nfor i in d:\n\td[i].sort()\nsas = {}\nfor i in d:\n\tsas[tuple(d[i])] = 0\nif len(sas) != 3:\n\tprint(-1)\nelse:\n\tnbs = []\n\tfor i in sas:\n\t\tnbs.append(set(i))\n\ta = nbs[0].intersection(nbs[1])\n\tb = nbs[0].intersection(nbs[2])\n\tc = nbs[1].intersection(nbs[2])\n\tkol = [0]*(v+1)\n\tfor i in a:\n\t\tkol[i] = 1\n\tfor i in b:\n\t\tkol[i] = 2\n\tfor i in c:\n\t\tkol[i] = 3\n\tzer = 0\n\tfor i in range(1,len(kol)):\n\t\tif kol[i] == 0:\n\t\t\tzer += 1\n\t\t\tbreak\n\tif zer > 0:\n\t\tprint(-1)\n\telse:\n\t\tif len(a)+len(b)+len(c) !=v:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(*kol[1:])", "# https://codeforces.com/contest/1228/problem/D\n# all neightbor in group --> pass 1\n# all neighbor not in group --> merge 0\n# invalid 2\n# WA\ndef type_(list_v, group):\n    cnt_0 = 0\n    cnt_1 = 0\n    \n    for v in list_v:\n        if v in group:\n            cnt_1 += 1\n        else:\n            cnt_0 += 1\n            \n    if cnt_1 == len(group):\n        return 1\n    \n    if cnt_0 == len(list_v):\n        return 0\n    \n    return 2\n    \ndef is_all_type_1(ex_index, list_group, v):\n    for i, group in list(list_group.items()):\n        if i == ex_index:\n            continue\n            \n        if type_(g[v], group) != 1: \n            return False\n        \n    return True\n    \ndef check(v, list_group):\n    t = None\n    for i, group in list(list_group.items()):\n        t  = type_(g[v], group)\n        \n        if t == 0 or t == 2:\n            if t == 0:\n                if is_all_type_1(i, list_group, v) == True:\n                    group[v] = 1\n                else:\n                    return 2\n            return t\n        \n    return t    \n    \ngroup = {}    \ndef process(g):    \n    for v in g:\n        if len(group) == 0:\n            group[0]    = {}\n            group[0][v] = 1\n            continue\n    \n        t = check(v, group)\n        \n        if t == 2:\n            return -1\n        \n        if t == 1:\n            if len(group) == 3:\n                return -1\n            \n            group[len(group)]    = {}\n            group[len(group)-1][v] = 1\n    return group\n\ng = {}\nn, m = list(map(int, input().split()))\n\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    if u not in g:\n        g[u] = []\n    if v not in g:\n        g[v] = []\n        \n    g[u].append(v)    \n    g[v].append(u)\n    \nans = process(g)\n\nif ans == -1 or len(ans) < 3:\n    print(-1)\nelse:\n    pr  = [0] * n\n    \n    cnt = 0\n    for k, gr in list(group.items()):\n        for v in gr:\n            cnt += 1\n            pr[v-1] = str(k+1)\n    \n    if cnt == n:\n        print(' '.join(pr))\n    else:\n        print(-1)\n# 1,2  3,4  5,6\n#6 12\n#1 3\n#1 4\n#2 3\n#2 4\n#1 5 \n#1 6\n#2 5\n#2 6\n#3 5\n#3 6\n#4 5\n#4 6\n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nN,M = inpl()\n\nif M == 0:\n    print(-1)\n    return\n\ncnts = [0]*N\nlines = defaultdict(set)\nfor _ in range(M):\n    a,b = inpl()\n    a-=1 ; b-=1\n    cnts[a] += 1\n    cnts[b] += 1\n    lines[a].add(b)\n    lines[b].add(a)\n\nsetc = set(cnts)\nL = len(setc)\nans = [-1]*N\nif L == 1:\n    ans[a] = 1\n    ans[b] = 2\n    for i in range(N):\n        if ans[i] != 0:\n            if i not in lines[a]:\n                ans[i] = 1\n            elif i not in lines[b]:\n                ans[i] = 2\n            else:\n                ans[i] = 3\nelif L == 2:\n    c1,c2 = list(setc)\n    if c1*2 + c2 == N*2:\n        i1 = cnts.index(c1)\n        i2 = cnts.index(c2)\n        for i,c in enumerate(cnts):\n            if c == c2:\n                ans[i] = 2\n            else:\n                if i not in lines[i1]:\n                    ans[i] = 1\n                else:\n                    ans[i] = 3\n    elif c1 + c2*2 == N*2:\n        i1 = cnts.index(c1)\n        i2 = cnts.index(c2)\n        for i,c in enumerate(cnts):\n            if c == c1:\n                ans[i] = 1\n            else:\n                if i not in lines[i2]:\n                    ans[i] = 2\n                else:\n                    ans[i] = 3\n    else:\n        print(-1)\n        return\nelif L == 3:\n    c1,c2,c3 = list(setc)\n    for i,c in enumerate(cnts):\n        if c == c1:\n            ans[i] = 1\n        elif c == c2:\n            ans[i] = 2\n        elif c == c3:\n            ans[i] = 3\nelse:\n    print(-1)\n    return\n\n\nif len(set(ans)) != 3:\n    print(-1)\n    return\n\nfor s in range(N):\n    for t in lines[s]:\n        if ans[s] == ans[t]:\n            print(-1)\n            return\n\nprint(' '.join(map(str,ans)))\n", "import sys\ndef fill(graph,n):\n    \n    dp=[[True,True,True] for _ in range(n+1)]\n    l=[-1 for i in range(n+1)]\n    from collections import defaultdict\n    vis=defaultdict(int)\n    count1,count2,count3=0,0,0\n    for i in graph:\n        if dp[i][0]:\n            #fill\n            l[i],count1=1,count1+1\n            vis[i]=1\n            for j in graph[i]:\n                dp[j][0]=False\n        elif dp[i][1]:\n            #fill\n            l[i]=2\n            count2+=1\n            vis[i]=2\n            for j in graph[i]:\n                dp[j][1]=False\n        elif dp[i][2]:\n            #fill\n            l[i]=3\n            count3+=1\n            vis[i]=3\n            for j in graph[i]:\n                dp[j][2]=False\n        else:\n            return [-1]\n    \n    if count1==0 or count2==0 or count3==0:\n        return [-1]\n    if count1+count2+count3!=n:\n        return [-1]\n    if count1*count2+count2*count3+count1*count3!=m:\n        return [-1]\n    l.pop(0)\n    for i in l:\n        if i==-1:\n            return [-1]\n    return l\nn,m=list(map(int,sys.stdin.readline().split()))\nfrom collections import defaultdict\ngraph=defaultdict(list)\nfor i in range(m):\n    a,b=list(map(int,sys.stdin.readline().split()))\n    graph[a].append(b)\n    graph[b].append(a)\nk=fill(graph,n)\nprint(*k)\n", "a=list(map(int,input().split()))\nn=a[0]\ne=a[1]\ng={}\nfor itr in range(1,n+1):\n    g[itr]=[]\nfor i in range(e):\n    a=list(map(int,input().split()))\n    g[a[0]].append(a[1])\n    g[a[1]].append(a[0])\nfor itr in range(1,n+1):\n    g[itr]=frozenset(g[itr])\na={}\nk=1\nres=[]\nfor i in range(1,n+1):\n    if len(g[i])==0:\n        k=100\n        break\n    if g[i] in a: \n        res.append(a[g[i]])\n    else: \n        a[g[i]]=k\n        k+=1\n        res.append(a[g[i]])\n    if len(a)>3:break\nif k!=4 : print(-1)\nelse: print(*res)", "n,m=list(map(int,input().split()))\nEE=[]\nif m<3:\n  print(-1)\nelse:\n  edge = [set() for i in range(n)]\n  a,b=list(map(int,input().split()))\n  edge[a-1].add(b-1)\n  edge[b-1].add(a-1)\n  EE.append([a-1,b-1])\n\n  for i in range(m-1):\n    x,y=list(map(int,input().split()))\n    edge[x-1].add(y-1)\n    edge[y-1].add(x-1)\n    EE.append([x-1,y-1])\n  c=0  \n  for i in range(n):\n    if a-1 in edge[i] and b-1 in edge[i]:\n      c=i+1\n      break\n  if c==0:\n    print(-1)\n  else:\n    Ans=[0]*n\n    Ans[a-1]=1\n    Ans[b-1]=2\n    Ans[c-1]=3\n    flg=True\n    C=[1]*3\n    for i in range(n):\n      if Ans[i]!=0:\n        continue\n      else:\n        E=edge[i]\n        if a-1 in E and b-1 in E and c-1 not in E:\n          Ans[i]=3\n          C[2]+=1\n        elif a-1 in E and b-1 not in E and c-1 in E:\n          Ans[i]=2\n          C[1]+=1\n        elif a-1 not in E and b-1 in E and c-1 in E:\n          Ans[i]=1\n          C[0]+=1\n        else:\n          print(-1)\n          flg=False\n          break\n    if flg:\n      T=[0]*3\n      for x,y in EE:\n        xx,yy=Ans[x],Ans[y]\n        if xx==yy:\n          print(-1)\n          flg=False\n          break\n        elif xx==1 and yy==2:\n          T[0]+=1\n        elif xx==2 and yy==1:\n          T[0]+=1\n        elif xx==1 and yy==3:\n          T[1]+=1\n        elif xx==3 and yy==1:\n          T[1]+=1\n        else:\n          T[2]+=1\n    if flg:\n      if T[0]==C[0]*C[1] and T[1]==C[0]*C[2] and T[2]==C[1]*C[2]:\n        print(*Ans)\n      else:\n        print(-1)\n\n\n\n\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n \nN, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n \ninf = 1 << 20\nA, B, C = [], [], []\nX = [0] * N\nfor a in E[0]:\n    X[a] = 1\nA = [i for i in range(N) if X[i]==0]\nb = min([i for i in range(N) if X[i] == 1] + [inf])\nif b < inf:\n    for a in E[b]:\n        if X[a] == 1: X[a] = 2\n    B = [i for i in range(N) if X[i]==1]\nc = min([i for i in range(N) if X[i] == 2] + [inf])\nif c < inf:\n    for a in E[c]:\n        if X[a] == 2: X[a] = 3\n    C = [i for i in range(N) if X[i]==2]\n \nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\n    f = 0\n    for i in range(N):\n        for j in E[i]:\n            if X[i] == X[j]:\n                f = 1\n                break\n        if f: break\n    if f:\n        print(-1)\n    else:\n        print(*[x+1 for x in X])\nelse:\n    print(-1)", "n,m=list(map(int,input().split()))\nEE=[]\nif m<3:\n  print(-1)\nelse:\n  edge = [[] for i in range(n)]\n  a,b=list(map(int,input().split()))\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n  EE.append([a-1,b-1])\n\n  for i in range(m-1):\n    x,y=list(map(int,input().split()))\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n    EE.append([x-1,y-1])\n  c=0  \n  for i in range(n):\n    if a-1 in edge[i] and b-1 in edge[i]:\n      c=i+1\n      break\n  if c==0:\n    print(-1)\n  else:\n    Ans=[0]*n\n    Ans[a-1]=1\n    Ans[b-1]=2\n    Ans[c-1]=3\n    flg=True\n    C=[1]*3\n    for i in range(n):\n      if Ans[i]!=0:\n        continue\n      else:\n        E=edge[i]\n        if a-1 in E and b-1 in E and c-1 not in E:\n          Ans[i]=3\n          C[2]+=1\n        elif a-1 in E and b-1 not in E and c-1 in E:\n          Ans[i]=2\n          C[1]+=1\n        elif a-1 not in E and b-1 in E and c-1 in E:\n          Ans[i]=1\n          C[0]+=1\n        else:\n          print(-1)\n          flg=False\n          break\n    if flg:\n      T=[0]*3\n      for x,y in EE:\n        xx,yy=Ans[x],Ans[y]\n        if xx==yy:\n          print(-1)\n          flg=False\n          break\n        elif xx==1 and yy==2:\n          T[0]+=1\n        elif xx==2 and yy==1:\n          T[0]+=1\n        elif xx==1 and yy==3:\n          T[1]+=1\n        elif xx==3 and yy==1:\n          T[1]+=1\n        else:\n          T[2]+=1\n    if flg:\n      if T[0]==C[0]*C[1] and T[1]==C[0]*C[2] and T[2]==C[1]*C[2]:\n        print(*Ans)\n      else:\n        print(-1)\n\n\n\n\n\n", "3\n\nimport array\nimport math\nimport os\nimport random\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    A = {}\n\n    for i in range(N):\n        t = frozenset(G[i])\n        if t not in A:\n            A[t] = set([i])\n        else:\n            A[t].add(i)\n\n    if len(A) != 3:\n        return None\n\n    (a1, v1), (a2, v2), (a3, v3) = A.items()\n    v1 = frozenset(v1)\n    v2 = frozenset(v2)\n    v3 = frozenset(v3)\n\n    if a1 != v2 | v3 or a2 != v3 | v1 or a3 != v1 | v2:\n        return None\n\n    ans = [0] * N\n    for v in v1:\n        ans[v] = 1\n    for v in v2:\n        ans[v] = 2\n    for v in v3:\n        ans[v] = 3\n    return ans\n\n\ndef main():\n    N, M = [int(e) for e in inp().split()]\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    if not ans:\n        print('-1')\n    else:\n        print(*ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "3\n\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    A = {}\n\n    for i in range(N):\n        t = frozenset(G[i])\n        if t not in A:\n            A[t] = set([i])\n        else:\n            A[t].add(i)\n\n    if len(A) != 3:\n        return None\n\n    (a1, v1), (a2, v2), (a3, v3) = A.items()\n    v1 = frozenset(v1)\n    v2 = frozenset(v2)\n    v3 = frozenset(v3)\n\n    if a1 != v2 | v3 or a2 != v3 | v1 or a3 != v1 | v2:\n        return None\n\n    ans = [0] * N\n    for v in v1:\n        ans[v] = 1\n    for v in v2:\n        ans[v] = 2\n    for v in v3:\n        ans[v] = 3\n    return ans\n\n\ndef main():\n    N, M = [int(e) for e in inp().split()]\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    if not ans:\n        print('-1')\n    else:\n        print(*ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\nmaxi=1000009\nd={}\na=[['0'] for i in range(n+1)]\n\nfor i in range(m):\n    u,v=map(int,input().split())\n    a[u].append(str(v)+'*')\n    a[v].append(str(u)+'*')\n\ncount=1\nfor i in range(1,n+1):\n    if len(a[i])==1:\n        print(\"-1\")\n        return\n    a[i].sort()\nfor i in range(1,n+1):    \n    a[i]=\"\".join(a[i])\n    #print(a[i])\nfor i in range(1,n+1):\n    if a[i] not in d:\n        d[a[i]]=count\n        count+=1\n#print(d)  \nif len(d)!=3:\n    #print(s)\n    print(\"-1\")\n    return\nfor i in range(1,n+1):\n    print(d[a[i]],end=\" \")\n  ", "n,m=map(int,input().split())\nd={}\na=[['0'] for i in range(n+1)]\nfor i in range(m):\n    u,v=map(int,input().split())\n    a[u].append(str(v)+'*')\n    a[v].append(str(u)+'*')\ncount=1\nfor i in range(1,n+1):\n    if len(a[i])==1:\n        print(\"-1\")\n        return\n    a[i].sort()\nfor i in range(1,n+1):    \n    a[i]=\"\".join(a[i])\nfor i in range(1,n+1):\n    if a[i] not in d:\n        d[a[i]]=count\n        count+=1\nif len(d)!=3:\n    print(\"-1\")\n    return\nfor i in range(1,n+1):\n    print(d[a[i]],end=\" \")\n  \n    ", "n,m=map(int,input().split())\nd={}\na=[['0'] for i in range(n+1)]\nfor i in range(m):\n    u,v=map(int,input().split())\n    a[u].append(str(v)+'*')\n    a[v].append(str(u)+'*')\ncount=1\nfor i in range(1,n+1):\n    if len(a[i])==1:\n        print(\"-1\")\n        return\n    a[i].sort()\nfor i in range(1,n+1):    \n    a[i]=\"\".join(a[i])\nfor i in range(1,n+1):\n    if a[i] not in d:\n        d[a[i]]=count\n        count+=1\nif len(d)!=3:\n    print(\"-1\")\n    return\nfor i in range(1,n+1):\n    print(d[a[i]],end=\" \")\n  ", "try:\n    from string_source import string_source\nexcept ImportError:\n    source = input\n\nfrom collections import defaultdict\n\n\ndef complete_bipartite(n, edges):\n    if not edges:\n        return False\n\n    neighbors = defaultdict(set, {})\n\n    for e1, e2 in edges:\n        neighbors[e1].add(e2)\n        neighbors[e2].add(e1)\n\n    s1, s2 = edges[0]\n\n    groups = [None, None, None]\n    groups[2] = neighbors[s1].intersection(neighbors[s2])\n    groups[1] = neighbors[s1].difference(neighbors[s2])\n    groups[0] = set(neighbors).difference(groups[2], groups[1])\n\n    def get_group(node):\n        return next(idx for idx, g in enumerate(groups) if node in g)\n\n    sizes = [len(g) for g in groups]\n\n    if sum(len(g) for g in groups) < n:\n        return False\n    if any(len(g) == 0 for g in groups):\n        return False\n\n    for e1, e2 in edges:\n        if get_group(e1) == get_group(e2):\n            return False\n\n    answer = [0] * n\n    for node, neigh in list(neighbors.items()):\n        g = get_group(node)\n        if sum(s for idx, s in enumerate(sizes) if idx != g) != len(neigh):\n            return False\n\n        answer[node - 1] = g + 1\n\n    return answer\n\n\ndef answer(source):\n    n, m = list(map(int, source().strip().split()))\n    edges = [[int(k) for k in source().strip().split()] for _ in range(m)]\n\n    a = complete_bipartite(n, edges)\n    if not a:\n        print(-1)\n    else:\n        print(\" \".join(map(str, a)))\n\n\nanswer(input)\n\nif False:\n    answer(\n        string_source(\n            \"\"\"6 11\n    1 2\n    1 3\n    1 4\n    1 5\n    1 6\n    2 4\n    2 5\n    2 6\n    3 4\n    3 5\n    3 6\"\"\"\n        )\n    )\n\n    answer(\n        string_source(\n            \"\"\"4 6\n    1 2\n    1 3\n    1 4\n    2 3\n    2 4\n    3 4\"\"\"\n        )\n    )\n"]