["#!/usr/bin/env python\n\nimport sys\n\nsys.setrecursionlimit(10000)\n\nn, m = list(map(int, input().split(' ')))\n\ndef neighbors(i, j):\n    return [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\n\ndef valid(i, j):\n    nonlocal n, m\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    return True\n\ndef dfs(f, i, j):\n    color = f[i][j]\n    f[i][j] = color.lower()\n    c = 0\n    for n, m in neighbors(i, j):\n        if valid(n, m):\n            if f[n][m] == color:\n                cycle_found = dfs(f, n, m)\n                if cycle_found:\n                    return True\n            elif f[n][m] == color.lower():\n                c += 1\n    if c > 1:\n        return True\n\n    f[i][j] = None\n\n    return False\n\nf = []\nfor i in range(n):\n    f.append(list(input().strip()))\n\nfor i in range(n):\n    for j in range(m):\n        if f[i][j]:\n            cycle_found = dfs(f, i, j)\n            if cycle_found:\n                print(\"Yes\")\n                return\n\nprint(\"No\")\n", "import sys\nsys.setrecursionlimit(10000)\n\nn, m = map(int, input().split())\nA = []\n\nfor i in range(n):\n    A.append(input() + '1')\n\nA.append('1' * (m + 1))\nans = 0\nused = [[False] * m for i in range(n)]\nB = ''.join(A)\nB = list(set(B))\ndef dfs(i, j, b, c):\n    nonlocal ans\n    used[i][j] = True\n    \n    if A[i - 1][j] == b and c != 3:\n        if used[i - 1][j]:\n            ans = 1\n        else:\n            dfs(i - 1, j, b, 1)\n\n    if A[i][j + 1] == b and c != 4:\n        if used[i][j + 1]:\n            ans = 1\n        else:\n            dfs(i, j + 1, b, 2)\n\n    if A[i + 1][j] == b and c != 1:\n        if used[i + 1][j]:\n            ans = 1\n        else:\n            dfs(i + 1, j, b, 3)\n\n    if A[i][j - 1] == b and c != 2:\n        if used[i][j - 1]:\n            ans = 1\n        else:\n            dfs(i, j - 1, b, 4)\n\nfor i in range(len(B)):\n    used = [[False] * m for i in range(n)]\n    if B[i] != '1':\n        b = B[i]\n        for x in range(n):\n            for y in range(m):\n                if A[x][y] == b and not used[x][y]:\n                    dfs(x, y, b, -1)\n\nif ans == 0:\n    print('No')\nelse:\n    print('Yes')", "import math\nln, cl = (int(x) for x in input().split())\n\nin_dt = []\n\nfor i in range(ln):\n    in_dt.append(input())\n\ndef is_adj(x_1, y_1, x_2, y_2):\n    if math.abs(x_2 - x_1) == 1 and y_2 - y_1 == 0:\n        return True\n    elif math.abs(y_2 - y_1) == 1 and x_2 - x_1 == 0:\n        return True\n    return False\n\nch_dt = [[0 for x in range(55)] for y in range(55)]\n\ndef neighb(x, y, ln, cl, lst):\n    res = []\n    if x - 1 >= 0 and lst[x][y] == lst[x - 1][y]:\n        res.append((x - 1, y))\n    if y - 1 >= 0 and lst[x][y] == lst[x][y - 1]:\n        res.append((x, y - 1))\n    if x + 1 < ln and lst[x][y] == lst[x + 1][y]:\n        res.append((x + 1, y))\n    if y + 1 < cl and lst[x][y] == lst[x][y + 1]:\n        res.append((x, y + 1))\n    return res\n\npath = []\n\ndef go_path(lst, path):\n    nonlocal ln\n    nonlocal cl\n    while True:\n        if len(path) == 0:\n            break\n        cur_x = path[-1][0]\n        cur_y = path[-1][1]\n        del path[-1]\n        #print (cur_x, cur_y)\n        #print (path)\n        neighbours = neighb(cur_x, cur_y, ln, cl, lst)\n        #print(neighbours)\n        if len(neighbours) != 0:\n            for neighbour in neighbours:\n                if neighbour in path:\n                    return True\n                # print (\"_______\")\n                #print (ch_dt)\n                #print (neighbour)\n                #print (\"+++++++\")\n                if ch_dt[neighbour[0]][neighbour[1]] == 0: \n                    path.append(neighbour)\n                    ch_dt[neighbour[0]][neighbour[1]] = 1\n        #print(path)\n    #print (False)\n    return False\nfor i in range(ln):\n    for j in range(cl):\n        if ch_dt[i][j] == 0:\n            ch_dt[i][j] = 1\n            path.append((i, j))\n            if go_path(in_dt, path):\n                print (\"Yes\")\n                return\nprint(\"No\")\n", "n, m = map(int, input().split())\ntabl = []\nfor l in range(n):\n    tabl.append(list(input()))\ndef lstsos(i, j):\n    nonlocal n, m\n    ne = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n    for l, k in ne:\n        if 0 <= l < n and 0 <= k < m:\n            yield (l, k)\ndef degree(i, j):\n    deg = 0\n    for l, k in lstsos(i, j):\n        deg += (tabl[l][k] == tabl[i][j])\n    return deg\nfinished = False\nwhile not finished:\n    finished = True\n    for l in range(n):\n        for k in range(m):\n            if tabl[l][k] != 'NO' and degree(l, k) in (0, 1):\n                tabl[l][k] = 'NO'\n                finished = False\ncycle = False\nfor l in range(n):\n    for k in range(m):\n        if tabl[l][k] != 'NO':\n            cycle = True\nif cycle:\n    print (\"Yes\")\nelse:\n    print (\"No\")", "n, m = [int(x) for x in input().split()]\n\nfield = [\"\"] * n\nlabels = [[0]] * n\n\nimport sys\nsys.setrecursionlimit(10000)\n\nfor i in range(n):\n    field[i] = input().strip()\n    labels[i] = [0] * m\n\ndef is_valid(i, j):\n    return 0 <= i < n and 0 <= j < m\n\n\ndef dfs(i, j, p, k, cc = 0):\n    if labels[i][j] == k:\n        return True\n    labels[i][j] = k\n\n    res = False\n    dd = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    for d in dd:\n        if is_valid(i + d[0], j + d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\n            if field[i + d[0]][j + d[1]] == field[i][j]:\n                res = res or dfs(i + d[0], j + d[1], [i, j], k, cc + 1)\n\n    return res\n\nok = False\nk = 1\nfor i in range(n):\n    for j in range(m):\n        if labels[i][j] == 0:\n            ok = ok or dfs(i, j, [i, j], k)\n            k += 1\n\nif ok:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "def main():\n    n, m = list(map(int, input().split()))\n    l = [c for _ in range(n) for c in input()]\n    neigh = []\n    for y in range(n):\n        for x in range(m):\n            yx = y * m + x\n            neigh.append([])\n            if x and l[yx] == l[yx - 1]:\n                neigh[-1].append(yx - 1)\n                neigh[-2].append(yx)\n            if y and l[yx] == l[yx - m]:\n                neigh[-1].append(yx - m)\n                neigh[-1 - m].append(yx)\n    field = [0] * len(l)\n\n    def dfs(t):\n        field[t] = 1\n        for v in neigh[t]:\n            if not field[v]:\n                neigh[v].remove(t)\n                dfs(v)\n            elif field[v] == 1:\n                raise OverflowError\n        field[t] = 2\n\n    for i, flag in enumerate(field):\n        if not flag:\n            try:\n                dfs(i)\n            except OverflowError:\n                print('Yes')\n                return\n    print('No')\n\n\ndef __starting_point():\n    import sys\n\n    sys.setrecursionlimit(10000)\n    main()\n\n__starting_point()", "#f = lambda: input()\n#file = open(\"btest\", \"r\")\n#f = lambda:file.readline()\n\n# n, m = map(int, f().split())\n\n# g = []\n\n# for i in range(n):\n#     g.append(f())\n\n# disco = [[False for _ in range(m)] for _ in range(n)]\n\n# #print(disco)\n# #print(parent)\n          \n# def found_cycle(w):\n#     nonlocal disco\n#     s = []\n#     s.append(w)\n#     while s:\n#         v = s.pop()\n#         if disco[v[0]][v[1]] == False:\n#             if v[0] > 0 and g[v[0]-1][v[1]] == g[v[0]][v[1]]:\n#                 s.append([v[0]-1, v[1]])\n                \n#             if v[0] < n-1 and g[v[0]+1][v[1]] == g[v[0]][v[1]]:\n#                 s.append([v[0]+1, v[1]])\n                \n#             if v[1] > 0 and g[v[0]][v[1]-1] == g[v[0]][v[1]]:\n#                 s.append([v[0], v[1]-1])\n                \n#             if v[1] < m-1 and g[v[0]][v[1]+1] == g[v[0]][v[1]]:\n#                 s.append([v[0], v[1]+1])\n                \n#         else:\n#             disco[v[0]][v[1]] = True\n#     return False\n\n# found = False\n# for i in range(n):\n#     if found:\n#         break\n#     for j in range(m):\n#         if disco[i][j] == False:\n#             found = found_cycle([i,j])\n#             break\n\n# if found:\n#     print (\"Yes\")\n# else:\n#     print (\"No\")\n\n#Editorial\nimport sys\nsys.setrecursionlimit(10000)\n\n#file = open(\"btest\", \"r\")\n#f = lambda:file.readline()\nf = lambda:input()\n\nn,m = list(map(int, f().split()))\n\nmatrix = []\n\ndisco = [[0 for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    matrix.append(f())\n\ndef valid_node(i, j):\n    return 0 <= i < n and 0 <= j < m\n\ndef dfs(i, j, p, k, cc = 0):\n    if disco[i][j] == k:\n        return True\n    \n    disco[i][j] = k\n\n    res = False\n    dd = [[0,1], [1,0], [-1,0], [0,-1]]\n    for d in dd:\n        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\n            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:\n                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)\n\n    return res\n\nok = False\nk = 1\nfor i in range(n):\n    for j in range(m):\n        if disco[i][j] == 0:\n            ok = ok or dfs(i, j, [i, j], k)\n            k += 1\n\nif ok:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "import sys\n#sys.stdin=open('in.txt')\nsys.setrecursionlimit(3000)\nisin = lambda x, y : 0<=x<m and 0<=y<n\n\ndef dfs(curx, cury, fax=-1, fay=-1):\n    nonlocal found\n    vis[curx][cury]=True\n    dx=[0, 0,1,-1]\n    dy=[1,-1,0, 0]\n    for i in range(4):\n        newx=curx+dx[i]\n        newy=cury+dy[i]\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax==newx and fay == newy):\n            found=True\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy] :\n            dfs(newx,newy,curx, cury)\n\nm,n = list(map(int, input().split()))\nvis=[[False]*n for i in range(m)]\nfound=False\nG=[input() for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        found=False\n        if not vis[i][j]:\n            dfs(i,j)\n        if found:\n            print('Yes')\n            return\n\nprint('No')\n", "import sys\n#sys.stdin=open('in.txt')\nsys.setrecursionlimit(10000)\nisin = lambda x, y: 0<=x<m and 0<=y<n\n\ndef dfs(curx, cury, fax=-1, fay=-1):\n    nonlocal found\n    vis[curx][cury]=True\n    dx=[0, 0, 1, -1]\n    dy=[1, -1, 0, 0]\n    for i in range(4):\n        newx=curx+dx[i]\n        newy=cury+dy[i]\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax == newx and fay == newy):\n            found=True\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy]:\n            dfs(newx, newy, curx, cury)   \n\nm,n = list(map(int, input().split()))\nvis=[[False]*n for i in range(m)]\nfound=False\nG=[input() for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        found = False\n        if not vis[i][j]:\n            dfs(i, j)\n        if found:\n            print('Yes')\n            return\nprint('No')    \n", "import sys\n#sys.stdin=open('in.txt')\nsys.setrecursionlimit(10000)\nisin = lambda x, y: 0<=x<m and 0<=y<n\n\ndef dfs(curx, cury, fax=-1, fay=-1):\n    nonlocal found\n    vis[curx][cury]=True\n    dx=[0, 0, 1, -1]\n    dy=[1, -1, 0, 0]\n    for i in range(4):\n        newx=curx+dx[i]\n        newy=cury+dy[i]\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax == newx and fay == newy):\n            found=True\n            return\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy]:\n            dfs(newx, newy, curx, cury)   \n\nm,n = list(map(int, input().split()))\nvis=[[False]*n for i in range(m)]\nfound=False\nG=[input() for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        found = False\n        if not vis[i][j]:\n            dfs(i, j)\n        if found:\n            print('Yes')\n            return\nprint('No')    \n", "import sys\nsys.setrecursionlimit(3000)\n\nn,m = map(int, input().split(' '))\nL = []\ndx = [-1, 0, 0, 1]\ndy = [0, -1, 1, 0]\nfor i in range(n) :\n    L.append(input())\n\ndef dfs(y, x, p_y, p_x, visited) :\n    nonlocal dx, dy, n, m, L\n    visited[y][x] = 1\n    for i in range(4) :\n        new_y = y + dy[i]\n        new_x = x + dx[i]\n        if new_y < 0 or new_y >= n or new_x < 0 or new_x >= m : continue\n        if new_y == p_y and new_x == p_x : continue\n        if L[y][x] == L[new_y][new_x] :\n            if visited[new_y][new_x] == 1: return True\n            if dfs(new_y, new_x, y, x, visited) : return True\n    return False\n\ndef solve() :\n    nonlocal n,m,L\n    visited = [[0 for j in range(m)] for i in range(n)]\n    for i in range(n) :\n        for j in range(m) :\n            if visited[i][j] == 1:continue\n            if dfs(i, j, -1, -1, visited) :\n                return True\n    return False\n\nif solve() : print(\"Yes\")\nelse : print(\"No\")", "import sys\n#sys.stdin = open('in.txt')\nsys.setrecursionlimit(10000)\nisin = lambda x, y: 0 <= x < n and 0 <= y < m\n\ndef dfs(curx, cury, fax = -1, fay = -1):\n    nonlocal found\n    vis[curx][cury] = True\n    dx = [1, -1, 0, 0]\n    dy = [0, 0, 1, -1]\n    for i in range(4):\n        newx = curx + dx[i]\n        newy = cury + dy[i]\n        if isin(newx, newy):\n            if G[curx][cury] == G[newx][newy] and vis [newx][newy] and not (newx == \n\nfax and newy == fay):\n                found = True\n                print(\"Yes\")\n                return\n            if G[curx][cury] == G[newx][newy] and not vis[newx][newy]:\n                dfs(newx, newy, curx, cury)\n\nn, m = map(int, input().split())\nvis = [[False] * m for _ in range(n)]\nG = [input() for _ in range(n)]\nfound = False\nfor i in range(n):\n    for j in range(m):\n        if not vis[i][j]:\n            dfs(i, j)\n        if found:\n            print('Yes')\n            return\nprint('No')", "import sys\ndef dfs(i,j,vis,out,mapp,s=2):\n    if vis[i][j] and vis[i][j]!= s-1:\n        return True\n    t=[(0,1),(1,0),(-1,0),(0,-1)]\n    vis[i][j]=s\n    out[i][j]=True\n    for k in t:\n        try:\n            (u,v)=(k[0]+i,k[1]+j)\n            if u<0 or v<0:\n                continue\n            if vis[u][v]!=s-1 and mapp[u][v]==mapp[i][j] and dfs(u,v,vis,out,mapp,s+1):\n                return True\n        except Exception:\n            pass\n    vis[i][j]=0\n    return False\nsys.setrecursionlimit(2500)\n(n,m)=input().split()\n(n,m)=(int(n),int(m))\nexist=set()\nmapp=[0 for i in range(n)]\nfor i in range(n):\n    mapp[i]=input()\nfor i in range(n):\n    for j in range(m):\n        exist.add(mapp[i][j])\nkey=0\nt=[(0,1),(1,0),(-1,0),(0,-1)]\nout=[[False for i in range(m)] for j in range(n)]\nfor c in exist:\n    if key:\n        break\n    vis=[[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        if key:\n            break\n        for j in range(m):\n            if key:\n                break\n            if mapp[i][j]==c and not out[i][j] and dfs(i,j,vis,out,mapp):\n                key=1\n                break\nif key:\n    print('Yes')\nelse:\n    print('No')\n                            \n                \n", "def q():\n    n,m=map(int,input().split())\n    p=[k for _ in range(n) for k in input()]\n    w=[]\n    for z in range(n):\n        for j in range(m):\n            ds=z*m+j\n            w.append([])\n            if j and p[ds]==p[ds-1]:\n                w[-1].append(ds-1)\n                w[-2].append(ds)\n            if z and p[ds]==p[ds-m]:\n                w[-1].append(ds-m)\n                w[-1-m].append(ds)\n    pol=[0]*len(p)\n    def zss(g):\n            pol[g]=1\n            for f in w[g]:\n                if not pol[f]:\n                    w[f].remove(g)\n                    zss(f)\n                elif pol[f]==1:\n                    raise OverflowError\n            pol[g]=2\n    for i,flag in enumerate(pol):\n        if not flag:\n            try:\n                zss(i)\n            except OverflowError:\n                print('Yes')\n                return\n    print('No')\nif 1==1:\n    import sys\n    sys.setrecursionlimit(10000)\n    q()", "t, u = list(map(int, input().split(' ')))\n\ndef ok(x, y, inx):\n    if not (0 <= x <= t-1 and 0 <= y <= u-1):\n        return False\n    if not inx[x][y]:\n        return False\n    return True\n        \n\n\ndef dfs(graph, start, path=[]):\n    inx = [[False] * u for _ in range(t)]\n    for i in graph:\n        a, b = i[0], i[1]\n        inx[a][b] = True\n    visited = [[False] * u for _ in range(t)]\n    parent = [[0] * u for _ in range(t)]\n    \n    q=[start]\n    \n    while q:\n        \n        bd = q.pop(0)\n        a = bd[0]\n        b = bd[1]\n\n        if not visited[a][b]:\n            for bad in [(a-1, b), (a, b-1), (a+1, b), (a, b+1)]:\n                x = bad[0]\n                y = bad[1]\n                if ok(x, y, inx):\n                    if visited[x][y] and (x, y) != parent[a][b]:\n                        return True\n                    q=[(x, y)]+q\n                    parent[x][y] = (a, b)\n            visited[a][b] = True\n    return False\n\ngraph = {}\nfor i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n    graph[i] = []\n\nfor i in range(t):\n    x = input()\n    for j in range(u):\n        graph[x[j]].append((i, j))\n\ngraph2 = {}\nfor i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n    if graph[i] != []:\n        graph2[i] = graph[i]\n\nfor i in graph2:\n    for e in graph2[i]:\n        if dfs(graph2[i], e):\n            print(\"Yes\")\n            quit()\n\n\nprint(\"No\")\n", "import sys\nsys.setrecursionlimit(10000)\n\ndef f(i, j):\n    return -1 < i < n and -1 < j < m\n\n\ndef dfs(c, r, l):\n    used[c][r] = 1\n    for (i, j) in {(0, 1), (-1, 0), (1, 0), (0, -1)}:\n        if f(c + i, r + j) and a[c + i][r + j] == a[c][r]:\n            if used[c + i][r + j] == 0:\n                prev[c + i][r + j] = (c, r)\n                dfs(c + i, r + j, l + 1)\n            elif used[c + i][r + j] == 1 and prev[c][r] != (c + i, r + j):\n                nonlocal s \n                s = \"Yes\"\n    used[i][j] = 2\n            \n\n\nn, m = map(int, input().split())\na = []\ns = \"No\"\nfor i in range(n):\n    a.append(list(input().rstrip()))\n\nused = [[0 for i in range(m)] for i in range(n)]\nprev = [[-1 for i in range(m)] for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if used[i][j] == 0:\n            dfs(i, j, 0)\nprint(s)", "import sys\nsys.setrecursionlimit(10000)\n\nn,m = map(int, input().split())\n\nboard = []\nfor _ in range(n):\n    board.append(input().rstrip())\n\nvisited = [[False for _ in range(m)] for _ in range(n)]\nfoundCycle = False\n    \ndx = [1,-1,0,0]\ndy = [0,0,1,-1]\n\ndef dfs(x, y, fromX, fromY, color):\n    nonlocal board, visited, foundCycle\n\n    if x < 0 or x >= n or y < 0 or y >= m: \n        return\n    if board[x][y] != color: \n        return\n\n    if visited[x][y]:\n        foundCycle = True\n        return\n    \n    visited[x][y] = True\n    for f in range(4):\n        nextX = x + dx[f]\n        nextY = y + dy[f]\n        if nextX == fromX and nextY == fromY:\n            continue\n        dfs(nextX, nextY, x, y, color)\n        \nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j]:\n            dfs(i,j,-1,-1, board[i][j])\nprint(\"Yes\" if foundCycle else \"No\")", "msg_in = input().split()\nx = int(msg_in[0])\ny = int(msg_in[1])\nnum_of_transform = [0, 0]\nmatrix = []\nblank = []\nfor i in range(y+2):\n    blank.append(' ')\nmatrix.append(blank)\nfor i in range(x):\n    msg_in = input()\n    matrix.append([' '])    \n    for j in msg_in:\n        matrix[i+1].append(j)\n    matrix[i+1].append(' ')\nmatrix.append(blank)\nwhile True:\n    for i in range(1, x + 1):\n        for j in range(1, y + 1):\n            sum = 0\n            if matrix[i][j] != ' ':\n                if matrix[i][j-1] == matrix[i][j]:\n                    sum += 1\n                if matrix[i][j+1] == matrix[i][j]:\n                    sum += 1\n                if matrix[i-1][j] == matrix[i][j]:\n                    sum += 1\n                if matrix[i+1][j] == matrix[i][j]:\n                    sum += 1\n                if sum < 2:\n                    matrix[i][j] = ' '\n                    num_of_transform[0] += 1\n    if num_of_transform[0] == x * y:\n        print('No')\n        break\n    elif num_of_transform[0] == num_of_transform[1]:\n        print('Yes')\n        break\n    else:\n        num_of_transform[1] = num_of_transform[0]\n", "# 510B\nimport string\n\n__author__ = 'artyom'\n\nn, m = map(int, input().split())\ngraph = []\nfor _ in range(n):\n  graph.append(input())\n\n\ndef neighbours(vertex, colour):\n  x, y = vertex\n  res = []\n  if x > 0 and graph[x - 1][y] == colour:\n    res.append((x - 1, y))\n  if y > 0 and graph[x][y - 1] == colour:\n    res.append((x, y - 1))\n  if x < n - 1 and graph[x + 1][y] == colour:\n    res.append((x + 1, y))\n  if y < m - 1 and graph[x][y + 1] == colour:\n    res.append((x, y + 1))\n  return res\n\n\ndef find_cycle(colour, start):\n  visited = set()\n  stack = [(start, None)]\n  while stack:\n    v, parent = stack.pop()\n    if v in visited:\n      return set()\n    visited.add(v)\n    for u in neighbours(v, colour):\n      if u != parent:\n        stack.append((u, v))\n  return visited\n\n\nfor c in string.ascii_uppercase:\n  visited = set()\n  for i in range(n):\n    for j in range(m):\n      if (i, j) not in visited and graph[i][j] == c:\n        t = find_cycle(c, (i, j))\n        if not t:\n          print('Yes')\n          return\n        visited |= t\n\nprint('No')", "# 510B\n__author__ = 'artyom'\n\nn, m = map(int, input().split())\ngraph = []\nfor _ in range(n):\n  graph.append(input())\n\n\ndef neighbours(vertex, colour):\n  x, y = vertex\n  res = []\n  if x > 0 and graph[x - 1][y] == colour:\n    res.append((x - 1, y))\n  if y > 0 and graph[x][y - 1] == colour:\n    res.append((x, y - 1))\n  if x < n - 1 and graph[x + 1][y] == colour:\n    res.append((x + 1, y))\n  if y < m - 1 and graph[x][y + 1] == colour:\n    res.append((x, y + 1))\n  return res\n\n\ndef find_cycle(x, y):\n  colour = graph[x][y]\n  visited = set()\n  stack = [((x, y), None)]\n  while stack:\n    v, parent = stack.pop()\n    if v in visited:\n      return set()\n    visited.add(v)\n    for u in neighbours(v, colour):\n      if u != parent:\n        stack.append((u, v))\n  return visited\n\n\nvisited = set()\nfor i in range(n):\n  for j in range(m):\n    if (i, j) not in visited:\n      t = find_cycle(i, j)\n      if not t:\n        print('Yes')\n        return\n      visited |= t\n\nprint('No')", "# coding=utf-8\nimport sys\n\nsys.setrecursionlimit(10000)\ng = []\n\nn, m = list(map(int, input().split()))\nidx = [[False for i in range(m)] for j in range(n)]\nfor k in range(n):\n    g.append(input())\n\n\ndef dfs(i, j, li, lj):\n    idx[i][j] = True\n    if i + 1 < n and g[i][j] == g[i + 1][j]:\n        if idx[i + 1][j] is False:\n            return dfs(i + 1, j, i, j)\n        elif not (li == i and lj == j) and i + 1 != li:\n            return 'Yes'\n    if i - 1 >= 0 and g[i][j] == g[i - 1][j]:\n        if idx[i - 1][j] is False:\n            return dfs(i - 1, j, i, j)\n        elif not (li == i and lj == j) and i - 1 != li:\n            return 'Yes'\n    if j - 1 >= 0 and g[i][j] == g[i][j - 1]:\n        if idx[i][j - 1] is False:\n            return dfs(i, j - 1, i, j)\n        elif not (li == i and lj == j) and j - 1 != lj:\n            return 'Yes'\n    if j + 1 < m and g[i][j] == g[i][j + 1]:\n        if idx[i][j + 1] is False:\n            return dfs(i, j + 1, i, j)\n        elif not (li == i and lj == j) and j + 1 != lj:\n            return 'Yes'\n    return None\n\n\nfor i in range(n):\n    for j in range(m):\n        if not idx[i][j]:\n            ans = dfs(i, j, i, j)\n            if ans:\n                print(ans)\n                break\n    else:\n        continue\n    break\nelse:\n    print('No')\n", "#A\n'''\nn, m = map(int, input().split())\nrow = ['#' * m if i % 2 == 0 else '.' * (m - 1) + '#' if i % 4 == 1\n       else '#' + '.' * (m - 1) for i in range(n)]\nprint('\\n'.join(row))\n'''\n#B\nimport sys\nsys.setrecursionlimit(5000)\nn, m = list(map(int, input().split()))\ndx = [-1, 0, 0, 1]\ndy = [0, -1, 1, 0]\nL = list(input() for i in range(n))\n\ndef check(x, y, px, py):\n    return (x >= 0 and x < n and y >= 0 and y < m)\n            \n\ndef DFS(x, y, px, py, visited):\n    #print(x, y, px, py, '\\n', visited)\n    visited[x][y] = True\n    for i in range(4):\n        newx = x + dx[i]\n        newy = y + dy[i]\n        if not check(newx, newy, px, py): continue\n        if (newx == px and newy == py): continue\n        #print('Bug ', visited)\n        if L[x][y] == L[newx][newy]:\n            if visited[newx][newy]:\n                #print('Here True', newx, newy, x, y)\n                return True\n            if DFS(newx, newy, x, y, visited):\n                #print(newx, newy, x, y, visited)\n                return True\n    return False\n        \ndef solve():\n#    visited = [[False] * m] * n\n    visited = [[False for j in range(m)] for i in range(n)]    \n    for i in range(n):\n        for j in range(m):\n            if visited[i][j]: continue\n            if DFS(i, j, -1, -1, visited): return True\n    return False\n\nprint('Yes' if solve() else 'No')\n'''\n3 3\nAAA\nABA\nABA\n'''\n"]